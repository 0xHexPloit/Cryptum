use crate::algorithms::byte_array::ByteArray;
use crate::algorithms::kyber::constants::KYBER_N_VALUE;
use crate::algorithms::kyber::cpapke::{KyberCPAPKE, KyberCPAPKE1024, KyberCPAPKE512, KyberCPAPKE768};
use crate::algorithms::utils::hash::{sha3_256, sha3_512, shake_256};

pub trait KyberAlgorithm {
    fn keygen(&self, seed: ByteArray) -> (ByteArray, ByteArray);
    fn encrypt(&self, public_key: ByteArray, seed: ByteArray, shared_secret_key_size: u8) -> (ByteArray, ByteArray);
    fn decrypt(&self, ciphertext: ByteArray, private_key: ByteArray, shared_secret_key_size: u8) -> ByteArray;

}

pub struct Kyber<const V: usize>(KyberCPAPKE<V>);


impl <const V: usize> KyberAlgorithm for Kyber<V> {
    /// This function corresponds to the KeyGen function (Algorithm 7)
    ///
    /// Input: None
    /// Output:
    ///     A bytes array of length (12路k路n)/8 + 32
    ///     A bytes array of length (24路k路n)/8 + 96
    fn keygen(&self, seed: ByteArray) -> (ByteArray, ByteArray){
        // Checking length of seed
        if seed.length() != 64 {
            panic!("Invalid length for seed. Should be 64 but found {}", seed.length());
        }
        let (seed_1, seed_2) = seed.split_at(32);

        let (public_key, private_key_prime) = self.0.keygen(seed_2);
        let hash = self.h(&public_key);

        let secret_key = ByteArray::concat(
            &[&private_key_prime, &public_key, &hash, &seed_1]
        );

        (public_key, secret_key)
    }

    /// This function correspond to the Enc function (Algorithm 8).
    ///
    /// Input:
    ///     public_key: A bytes array representing a public_key generating by the keygen function.
    ///     seed: A bytes array filled with random values. It should be of length 32
    ///     shared_secret_key_size: The size of the shared secret key to generate in bytes
    ///
    fn encrypt(&self, public_key: ByteArray, seed: ByteArray, shared_secret_key_size: u8) -> (ByteArray, ByteArray) {
        // Checking the length of the seed
        if seed.length() != 32 {
            panic!("Invalid length for seed ! It should be of length 32 found {}", seed.length())
        }

        // Checking the length of the public_key
        let expected_public_key_size = self.get_public_key_length();
        if public_key.length() != expected_public_key_size {
            panic!(
                "Invalid length for public_key! Expected {} found {}.",
                expected_public_key_size,
                public_key.length()
            );
        }

        let hash = self.h(&seed);
        let (k_bar, r) = self.g(
            &ByteArray::concat(
                &[&hash, &self.h(&public_key)]
            )
        );

        let ciphertext = self.0.encrypt(
            public_key,
            hash,
            r
        );

        let shared_secret = self.kdf(
            ByteArray::concat(
                &[&k_bar, &self.h(&ciphertext)]
            ),
            shared_secret_key_size
        );

        (ciphertext, shared_secret)
    }

    /// This function corresponds to the Dec function (Algorithm 8)
    ///
    /// Input:
    ///     ciphertext: A ciphertext produced by the encrypt function
    ///     private_key: A private_key generated by the keygen function
    ///     shared_secret_key_size: The size of the shared secret key to generate in bytes.
    /// Output:
    ///     A shared secret that can be used to encrypt data
    fn decrypt(&self, ciphertext: ByteArray, private_key: ByteArray, shared_secret_key_size: u8) -> ByteArray {
        // Checking the length of ciphertext
        let expected_ciphertext_length = self.0.get_ciphertext_length();

        if ciphertext.length() != expected_ciphertext_length {
            panic!(
                "Invalid length for ciphertext ! Expected {} found {}",
                expected_ciphertext_length,
                ciphertext.length()
            )
        }

        // Checking length of private key
        let expected_private_key_length = self.get_private_key_length();

        if private_key.length() != expected_private_key_length {
            panic!(
                "Invalid length for private key! Expected {} found {}",
                expected_private_key_length,
                private_key.length()
            )
        }

        let private_key_bytes = private_key.get_bytes();
        let k = self.0.get_k();

        let mut start_index = (12 * k as usize * KYBER_N_VALUE) / 8;
        let mut end_index = (24 * k as usize * KYBER_N_VALUE) / 8 + 32;

        let sub_private_key = &private_key_bytes[0..start_index];

        let pk = &private_key_bytes[start_index..end_index];

        start_index = end_index;
        end_index = (24 * k as usize * KYBER_N_VALUE) / 8 + 64;

        let h = &private_key_bytes[start_index..end_index];

        start_index = end_index;
        end_index = (24 * k as usize * KYBER_N_VALUE) / 8 + 96;

        let z = &private_key_bytes[start_index..end_index];

        let m_prime = self.0.decrypt(sub_private_key.into(), ciphertext.clone());

        let (k_bar, r_prime) = self.g(
            &ByteArray::concat(
                &[&m_prime, &h.into()]
            )
        );

        let c_prime = self.0.encrypt(pk.into(), m_prime, r_prime);

        if ciphertext == c_prime {
            self.kdf(
                ByteArray::concat(
                    &[&k_bar, &self.h(&ciphertext)]
                ),
                shared_secret_key_size
            )
        } else {
            self.kdf(
                ByteArray::concat(
                    &[&z.into(), &self.h(&ciphertext)]
                ),
                shared_secret_key_size
            )
        }
    }

}

impl Kyber<512> {
    pub fn init() -> Self {
        Self (KyberCPAPKE512::init())
    }
}

impl Kyber<768> {
    pub fn init() -> Self {
        Self(KyberCPAPKE768::init())
    }
}

impl Kyber<1024> {
    pub fn init() -> Self {
        Self (KyberCPAPKE1024::init())
    }
}

impl <const V: usize> Kyber<V> {
    /// This function corresponds to the H function that one can observe in the following algorithms:
    /// Algorithm 7 (Kyber.CCAKEM.KeyGen()), Algorithm 8 (Kyber.CCAKEM.Enc(pk)), Algorithm 9
    /// (Kyber.CCAKEM.Dec(c, sk)). According to the authors, the function is a wrapper around the
    /// Sha3-256 hash function.
    ///
    /// Input:
    ///     - data: A byte array
    /// Output:
    ///     A byte array of length 32 bytes
    fn h(&self, data: &ByteArray) -> ByteArray {
        sha3_256(data.get_bytes()).into()
    }



    fn get_public_key_length(&self) -> usize {
        let k = self.0.get_k();

        (12 * k as usize * KYBER_N_VALUE) / 8 + 32
    }

    fn get_private_key_length(&self) -> usize {
        let k = self.0.get_k();

        (24 * k as usize * KYBER_N_VALUE) / 8 + 96
    }


    /// This function corresponds to the KDF function that one can observe in both Algorithm
    /// 7 (Enc) and Algorithm 8 (Dec). According to the authors of the article, it simply
    /// represents a wrapper around the shake256 extendable-output function.
    ///
    /// Input:
    ///     data: A bytes array to be hashed
    ///     output_size: The number of bytes to generate
    /// Output:
    ///     A bytes array of length output_size
    fn kdf(&self, data: ByteArray, output_size: u8) -> ByteArray {
        shake_256(data.get_bytes(), output_size as usize).into()
    }

    /// This function corresponds to the G function that one can observe in both Algorithm 7 (Enc)
    /// and Algorithm 8
    ///
    /// Input:
    ///     data: A bytes array
    /// Output:
    ///     A tuple of bytes array each of them is of length 32
    ///
    fn g(&self, data: &ByteArray) -> (ByteArray, ByteArray) {
        let hash: ByteArray = sha3_512(data.get_bytes()).into();
        hash.split_at(32)
    }
}

pub type Kyber512 = Kyber<512>;
pub type Kyber768 = Kyber<768>;
pub type Kyber1024 = Kyber<1024>;

#[cfg(test)]
mod tests {
    use crate::algorithms::byte_array::ByteArray;
    use crate::algorithms::kyber::byte_array::ByteArray;
    use crate::algorithms::kyber::kem::Kyber512;
    use crate::algorithms::kyber::KyberAlgorithm;

    #[test]
    fn test_keygen() {
        let seed = ByteArray::from([0u8; 64].as_slice());
        let kyber = Kyber512::init();

        let (public_key, secret_key) = kyber.keygen(seed);

        let expected_public_key = ByteArray::from([156, 229, 198, 126, 252, 156, 51, 103, 168, 60, 124, 66, 176, 161, 41, 55, 201, 64, 207, 113, 26, 162, 167, 127, 148, 56, 146, 141, 105, 80, 234, 96, 7, 192, 185, 2, 255, 25, 119, 123, 32, 147, 18, 102, 6, 119, 0, 185, 105, 160, 36, 146, 236, 192, 102, 115, 206, 246, 225, 206, 54, 119, 58, 75, 219, 149, 56, 213, 52, 88, 38, 24, 222, 210, 121, 226, 153, 161, 32, 35, 24, 19, 140, 168, 213, 73, 182, 198, 8, 129, 238, 210, 183, 74, 184, 132, 185, 48, 116, 104, 83, 89, 96, 53, 39, 236, 99, 139, 171, 177, 61, 152, 242, 167, 62, 42, 54, 42, 86, 98, 163, 81, 83, 141, 83, 87, 236, 124, 32, 182, 103, 64, 128, 199, 106, 83, 101, 171, 159, 72, 63, 120, 108, 78, 44, 219, 202, 35, 240, 170, 10, 100, 88, 158, 184, 110, 170, 7, 55, 113, 240, 77, 57, 128, 142, 144, 68, 55, 104, 170, 13, 9, 34, 181, 223, 161, 84, 231, 231, 9, 61, 52, 34, 56, 20, 186, 161, 182, 109, 174, 54, 83, 206, 162, 21, 179, 172, 125, 108, 101, 184, 44, 49, 174, 223, 192, 62, 62, 246, 29, 210, 147, 21, 181, 193, 28, 16, 165, 185, 223, 19, 146, 23, 160, 194, 62, 244, 191, 129, 65, 14, 191, 22, 15, 91, 186, 77, 60, 103, 24, 179, 86, 177, 133, 101, 90, 190, 209, 66, 163, 196, 153, 5, 226, 40, 157, 212, 202, 5, 160, 58, 5, 11, 160, 8, 211, 82, 189, 34, 186, 235, 137, 120, 78, 252, 41, 1, 12, 162, 120, 74, 108, 33, 203, 70, 147, 121, 0, 153, 219, 158, 202, 147, 37, 81, 105, 149, 49, 100, 21, 136, 140, 53, 168, 52, 97, 187, 90, 134, 180, 37, 23, 178, 177, 86, 210, 133, 152, 201, 91, 117, 78, 27, 55, 79, 64, 160, 174, 83, 33, 105, 114, 118, 136, 103, 205, 69, 167, 202, 214, 213, 167, 56, 43, 42, 93, 124, 22, 148, 73, 110, 5, 72, 173, 244, 87, 27, 75, 92, 95, 93, 33, 147, 159, 188, 155, 242, 105, 205, 175, 83, 190, 95, 9, 190, 97, 147, 174, 186, 89, 31, 79, 193, 185, 67, 151, 121, 141, 185, 66, 231, 58, 117, 89, 0, 23, 190, 75, 70, 193, 233, 77, 208, 251, 27, 138, 148, 118, 242, 138, 207, 11, 33, 26, 193, 202, 128, 44, 168, 114, 62, 122, 111, 97, 241, 52, 60, 23, 69, 158, 85, 178, 115, 44, 206, 246, 60, 128, 190, 67, 89, 247, 246, 21, 249, 12, 46, 140, 108, 8, 35, 133, 174, 183, 21, 24, 137, 42, 28, 135, 203, 63, 54, 102, 129, 71, 217, 25, 193, 6, 107, 170, 105, 182, 227, 249, 153, 249, 38, 120, 13, 102, 23, 112, 21, 35, 64, 115, 29, 2, 118, 196, 84, 168, 108, 130, 224, 183, 76, 75, 76, 27, 119, 55, 242, 249, 174, 50, 34, 183, 208, 242, 203, 192, 1, 186, 84, 33, 204, 106, 26, 34, 208, 133, 135, 162, 88, 206, 66, 188, 105, 161, 114, 68, 118, 165, 167, 150, 185, 127, 161, 92, 133, 156, 124, 96, 106, 227, 44, 129, 188, 153, 57, 105, 153, 211, 69, 123, 180, 35, 149, 99, 42, 182, 153, 83, 64, 181, 20, 128, 15, 88, 46, 86, 149, 52, 208, 26, 39, 66, 220, 47, 10, 53, 191, 173, 97, 134, 56, 181, 155, 207, 195, 59, 180, 194, 77, 53, 231, 101, 98, 252, 75, 220, 68, 180, 22, 65, 49, 59, 12, 95, 202, 146, 108, 84, 211, 198, 66, 229, 42, 98, 6, 56, 103, 200, 186, 58, 10, 121, 118, 19, 94, 254, 59, 108, 73, 234, 38, 93, 85, 162, 209, 213, 103, 127, 73, 176, 158, 186, 56, 35, 74, 190, 56, 179, 149, 39, 168, 23, 66, 20, 78, 147, 67, 130, 178, 117, 100, 41, 42, 36, 214, 165, 56, 145, 107, 33, 72, 210, 63, 120, 231, 10, 89, 233, 128, 150, 201, 18, 3, 247, 121, 101, 33, 31, 46, 234, 47, 198, 252, 31, 89, 99, 78, 36, 107, 12, 158, 36, 118, 156, 229, 169, 79, 194, 124, 51, 213, 86, 80, 2, 143, 149, 27, 42, 48, 117, 201, 139, 135, 135, 70, 224, 61, 201, 28, 191, 221, 151, 37, 236, 9, 180, 77, 185, 15, 12, 102, 43, 165, 9, 110, 157, 171, 7, 106, 123, 123, 26, 202, 180, 235, 43, 121, 91, 101, 49, 173, 86, 195, 92, 171, 80, 99, 185, 231, 234, 86, 131, 20, 236, 129, 196, 11, 165, 119, 170, 230, 48, 222, 144, 32, 4, 0, 158, 136, 241, 141, 165].as_slice());
        let expected_secret_key = ByteArray::from([50, 193, 136, 186, 115, 194, 8, 3, 37, 219, 64, 59, 240, 247, 22, 1, 2, 119, 108, 71, 17, 52, 10, 26, 180, 134, 47, 42, 16, 47, 205, 74, 161, 57, 199, 207, 249, 241, 190, 196, 51, 68, 1, 144, 110, 56, 132, 70, 62, 148, 35, 15, 219, 28, 211, 183, 119, 38, 51, 97, 60, 73, 178, 2, 0, 166, 158, 48, 96, 52, 33, 88, 84, 103, 112, 21, 49, 74, 233, 213, 147, 139, 169, 184, 167, 129, 175, 49, 129, 8, 146, 89, 84, 61, 133, 172, 80, 55, 137, 13, 51, 67, 1, 231, 117, 236, 99, 29, 59, 69, 111, 20, 7, 2, 110, 116, 190, 142, 119, 64, 124, 153, 203, 198, 88, 163, 93, 59, 23, 177, 54, 33, 249, 38, 98, 185, 96, 180, 13, 27, 193, 74, 35, 72, 140, 248, 163, 228, 121, 200, 55, 98, 86, 234, 196, 10, 237, 69, 67, 104, 90, 97, 43, 135, 123, 166, 114, 186, 22, 188, 63, 208, 169, 77, 137, 226, 201, 51, 248, 35, 161, 169, 105, 159, 247, 182, 151, 155, 109, 45, 51, 142, 200, 50, 147, 234, 73, 150, 91, 2, 86, 101, 153, 27, 76, 7, 169, 109, 25, 86, 43, 179, 146, 234, 188, 168, 68, 114, 124, 127, 233, 87, 219, 151, 176, 132, 9, 185, 255, 184, 205, 206, 87, 68, 199, 220, 190, 199, 228, 98, 186, 150, 174, 244, 183, 169, 198, 42, 174, 88, 7, 188, 229, 219, 91, 16, 118, 148, 56, 120, 64, 80, 52, 25, 26, 75, 85, 25, 161, 193, 139, 162, 153, 26, 168, 73, 100, 22, 165, 171, 240, 65, 221, 120, 78, 39, 249, 158, 221, 155, 196, 108, 70, 78, 104, 200, 21, 115, 224, 155, 133, 228, 87, 100, 48, 185, 86, 81, 107, 4, 128, 21, 102, 58, 187, 91, 8, 8, 66, 52, 144, 204, 26, 13, 75, 97, 109, 17, 138, 172, 50, 199, 188, 119, 129, 103, 78, 152, 108, 153, 167, 62, 61, 234, 206, 77, 21, 26, 21, 36, 186, 106, 101, 21, 124, 130, 104, 190, 42, 13, 28, 245, 186, 0, 145, 102, 179, 41, 25, 46, 156, 137, 25, 83, 62, 192, 124, 78, 85, 122, 25, 94, 231, 85, 190, 71, 145, 39, 133, 109, 156, 74, 20, 58, 168, 7, 183, 106, 130, 166, 249, 168, 15, 81, 189, 93, 150, 185, 26, 32, 148, 228, 48, 193, 35, 6, 19, 56, 209, 5, 166, 1, 118, 56, 10, 113, 5, 107, 170, 194, 204, 18, 217, 8, 183, 149, 172, 149, 255, 203, 127, 30, 72, 9, 63, 129, 10, 250, 16, 59, 177, 10, 17, 59, 52, 58, 152, 235, 102, 152, 112, 9, 228, 2, 87, 187, 197, 107, 128, 227, 192, 107, 120, 42, 138, 196, 112, 153, 102, 184, 159, 17, 101, 52, 73, 60, 153, 11, 136, 0, 16, 9, 189, 213, 125, 3, 137, 162, 215, 119, 163, 63, 28, 195, 8, 108, 38, 200, 217, 113, 230, 54, 147, 60, 99, 86, 220, 248, 187, 8, 35, 2, 90, 153, 81, 193, 241, 58, 11, 10, 89, 103, 209, 180, 4, 180, 154, 44, 122, 167, 253, 12, 76, 49, 19, 138, 60, 107, 83, 73, 4, 110, 47, 122, 68, 140, 53, 0, 207, 92, 179, 84, 135, 54, 113, 96, 168, 73, 247, 153, 83, 0, 131, 156, 114, 28, 214, 91, 170, 47, 115, 128, 182, 44, 38, 180, 197, 143, 35, 122, 81, 73, 185, 186, 125, 89, 82, 206, 37, 105, 111, 4, 185, 208, 150, 29, 21, 136, 27, 72, 134, 201, 232, 198, 162, 238, 35, 8, 49, 12, 188, 167, 3, 82, 8, 83, 199, 189, 120, 90, 76, 120, 62, 194, 251, 198, 220, 25, 95, 100, 22, 84, 16, 243, 54, 107, 99, 104, 0, 199, 203, 94, 228, 29, 47, 188, 105, 91, 2, 117, 250, 121, 140, 53, 22, 103, 32, 90, 129, 5, 81, 35, 175, 122, 148, 39, 236, 17, 9, 251, 95, 78, 59, 35, 195, 106, 21, 246, 64, 69, 178, 80, 123, 36, 24, 116, 78, 99, 8, 49, 183, 192, 251, 212, 191, 77, 67, 79, 41, 215, 127, 84, 212, 57, 114, 59, 50, 2, 185, 154, 74, 226, 170, 91, 26, 167, 146, 193, 44, 87, 7, 112, 176, 101, 22, 150, 234, 60, 190, 251, 6, 200, 52, 141, 95, 37, 133, 47, 251, 51, 181, 214, 83, 197, 41, 92, 153, 144, 115, 168, 36, 102, 218, 194, 48, 122, 200, 23, 156, 229, 198, 126, 252, 156, 51, 103, 168, 60, 124, 66, 176, 161, 41, 55, 201, 64, 207, 113, 26, 162, 167, 127, 148, 56, 146, 141, 105, 80, 234, 96, 7, 192, 185, 2, 255, 25, 119, 123, 32, 147, 18, 102, 6, 119, 0, 185, 105, 160, 36, 146, 236, 192, 102, 115, 206, 246, 225, 206, 54, 119, 58, 75, 219, 149, 56, 213, 52, 88, 38, 24, 222, 210, 121, 226, 153, 161, 32, 35, 24, 19, 140, 168, 213, 73, 182, 198, 8, 129, 238, 210, 183, 74, 184, 132, 185, 48, 116, 104, 83, 89, 96, 53, 39, 236, 99, 139, 171, 177, 61, 152, 242, 167, 62, 42, 54, 42, 86, 98, 163, 81, 83, 141, 83, 87, 236, 124, 32, 182, 103, 64, 128, 199, 106, 83, 101, 171, 159, 72, 63, 120, 108, 78, 44, 219, 202, 35, 240, 170, 10, 100, 88, 158, 184, 110, 170, 7, 55, 113, 240, 77, 57, 128, 142, 144, 68, 55, 104, 170, 13, 9, 34, 181, 223, 161, 84, 231, 231, 9, 61, 52, 34, 56, 20, 186, 161, 182, 109, 174, 54, 83, 206, 162, 21, 179, 172, 125, 108, 101, 184, 44, 49, 174, 223, 192, 62, 62, 246, 29, 210, 147, 21, 181, 193, 28, 16, 165, 185, 223, 19, 146, 23, 160, 194, 62, 244, 191, 129, 65, 14, 191, 22, 15, 91, 186, 77, 60, 103, 24, 179, 86, 177, 133, 101, 90, 190, 209, 66, 163, 196, 153, 5, 226, 40, 157, 212, 202, 5, 160, 58, 5, 11, 160, 8, 211, 82, 189, 34, 186, 235, 137, 120, 78, 252, 41, 1, 12, 162, 120, 74, 108, 33, 203, 70, 147, 121, 0, 153, 219, 158, 202, 147, 37, 81, 105, 149, 49, 100, 21, 136, 140, 53, 168, 52, 97, 187, 90, 134, 180, 37, 23, 178, 177, 86, 210, 133, 152, 201, 91, 117, 78, 27, 55, 79, 64, 160, 174, 83, 33, 105, 114, 118, 136, 103, 205, 69, 167, 202, 214, 213, 167, 56, 43, 42, 93, 124, 22, 148, 73, 110, 5, 72, 173, 244, 87, 27, 75, 92, 95, 93, 33, 147, 159, 188, 155, 242, 105, 205, 175, 83, 190, 95, 9, 190, 97, 147, 174, 186, 89, 31, 79, 193, 185, 67, 151, 121, 141, 185, 66, 231, 58, 117, 89, 0, 23, 190, 75, 70, 193, 233, 77, 208, 251, 27, 138, 148, 118, 242, 138, 207, 11, 33, 26, 193, 202, 128, 44, 168, 114, 62, 122, 111, 97, 241, 52, 60, 23, 69, 158, 85, 178, 115, 44, 206, 246, 60, 128, 190, 67, 89, 247, 246, 21, 249, 12, 46, 140, 108, 8, 35, 133, 174, 183, 21, 24, 137, 42, 28, 135, 203, 63, 54, 102, 129, 71, 217, 25, 193, 6, 107, 170, 105, 182, 227, 249, 153, 249, 38, 120, 13, 102, 23, 112, 21, 35, 64, 115, 29, 2, 118, 196, 84, 168, 108, 130, 224, 183, 76, 75, 76, 27, 119, 55, 242, 249, 174, 50, 34, 183, 208, 242, 203, 192, 1, 186, 84, 33, 204, 106, 26, 34, 208, 133, 135, 162, 88, 206, 66, 188, 105, 161, 114, 68, 118, 165, 167, 150, 185, 127, 161, 92, 133, 156, 124, 96, 106, 227, 44, 129, 188, 153, 57, 105, 153, 211, 69, 123, 180, 35, 149, 99, 42, 182, 153, 83, 64, 181, 20, 128, 15, 88, 46, 86, 149, 52, 208, 26, 39, 66, 220, 47, 10, 53, 191, 173, 97, 134, 56, 181, 155, 207, 195, 59, 180, 194, 77, 53, 231, 101, 98, 252, 75, 220, 68, 180, 22, 65, 49, 59, 12, 95, 202, 146, 108, 84, 211, 198, 66, 229, 42, 98, 6, 56, 103, 200, 186, 58, 10, 121, 118, 19, 94, 254, 59, 108, 73, 234, 38, 93, 85, 162, 209, 213, 103, 127, 73, 176, 158, 186, 56, 35, 74, 190, 56, 179, 149, 39, 168, 23, 66, 20, 78, 147, 67, 130, 178, 117, 100, 41, 42, 36, 214, 165, 56, 145, 107, 33, 72, 210, 63, 120, 231, 10, 89, 233, 128, 150, 201, 18, 3, 247, 121, 101, 33, 31, 46, 234, 47, 198, 252, 31, 89, 99, 78, 36, 107, 12, 158, 36, 118, 156, 229, 169, 79, 194, 124, 51, 213, 86, 80, 2, 143, 149, 27, 42, 48, 117, 201, 139, 135, 135, 70, 224, 61, 201, 28, 191, 221, 151, 37, 236, 9, 180, 77, 185, 15, 12, 102, 43, 165, 9, 110, 157, 171, 7, 106, 123, 123, 26, 202, 180, 235, 43, 121, 91, 101, 49, 173, 86, 195, 92, 171, 80, 99, 185, 231, 234, 86, 131, 20, 236, 129, 196, 11, 165, 119, 170, 230, 48, 222, 144, 32, 4, 0, 158, 136, 241, 141, 165, 245, 250, 69, 171, 191, 220, 187, 152, 220, 74, 23, 246, 218, 233, 27, 140, 116, 133, 27, 16, 178, 162, 235, 30, 81, 86, 192, 46, 207, 86, 217, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].as_slice());

        assert_eq!(public_key, expected_public_key);
        assert_eq!(secret_key, expected_secret_key);
    }

    #[test]
    fn test_encrypt() {
        let seed = ByteArray::from([0u8; 64].as_slice());
        let kyber = Kyber512::init();
        let (public_key, _) = kyber.keygen(seed);

        let seed = ByteArray::from([0u8; 32].as_slice());
        let (ciphertext, secret_key) = kyber.encrypt(public_key, seed, 32);

        let expected_ciphertext = ByteArray::from([107, 219, 51, 13, 219, 123, 81, 60, 128, 221, 143, 204, 189, 49, 135, 124, 208, 92, 216, 102, 180, 159, 124, 17, 54, 152, 194, 133, 170, 43, 148, 146, 120, 210, 77, 84, 254, 253, 17, 144, 170, 248, 170, 186, 247, 11, 147, 164, 2, 116, 249, 179, 255, 243, 109, 200, 61, 192, 242, 16, 182, 161, 10, 83, 155, 80, 202, 60, 202, 195, 200, 148, 171, 29, 255, 49, 204, 109, 95, 127, 225, 223, 192, 143, 182, 244, 43, 76, 204, 64, 78, 129, 4, 228, 166, 78, 127, 4, 184, 239, 214, 127, 218, 83, 70, 178, 21, 69, 70, 140, 55, 203, 205, 164, 76, 122, 17, 71, 92, 233, 91, 233, 218, 97, 143, 168, 153, 209, 247, 120, 224, 85, 53, 241, 97, 244, 123, 74, 157, 249, 79, 106, 222, 141, 4, 1, 169, 214, 120, 213, 173, 168, 162, 72, 51, 110, 179, 94, 243, 126, 147, 93, 78, 37, 105, 204, 77, 137, 250, 199, 214, 113, 68, 247, 188, 49, 131, 153, 28, 145, 20, 40, 225, 59, 130, 127, 249, 15, 237, 93, 78, 106, 104, 173, 228, 47, 89, 65, 249, 171, 104, 224, 60, 194, 199, 18, 252, 210, 38, 179, 1, 45, 0, 172, 150, 205, 239, 225, 229, 246, 9, 129, 49, 29, 146, 237, 130, 95, 249, 25, 83, 243, 118, 59, 80, 149, 148, 245, 109, 71, 184, 3, 200, 227, 38, 59, 62, 79, 222, 138, 27, 29, 91, 97, 229, 249, 221, 102, 106, 36, 57, 145, 15, 86, 181, 246, 228, 182, 79, 52, 48, 166, 245, 54, 44, 86, 85, 198, 247, 30, 22, 177, 69, 233, 215, 214, 13, 152, 186, 1, 181, 157, 37, 75, 12, 110, 115, 232, 124, 87, 43, 113, 106, 2, 77, 110, 50, 152, 204, 127, 225, 164, 165, 166, 22, 40, 215, 35, 2, 115, 23, 243, 103, 107, 23, 43, 193, 92, 200, 187, 33, 113, 183, 43, 114, 46, 223, 155, 90, 23, 224, 237, 139, 203, 24, 175, 36, 250, 66, 47, 157, 76, 238, 39, 58, 39, 249, 254, 170, 62, 19, 215, 3, 243, 153, 192, 149, 166, 62, 205, 162, 86, 32, 193, 45, 240, 162, 40, 27, 245, 12, 74, 55, 255, 135, 174, 51, 248, 161, 170, 184, 236, 1, 90, 73, 158, 49, 232, 16, 191, 71, 155, 31, 168, 133, 10, 158, 110, 19, 80, 20, 18, 220, 71, 102, 140, 97, 232, 26, 69, 38, 190, 188, 141, 75, 243, 210, 96, 52, 58, 105, 196, 197, 190, 49, 250, 11, 122, 177, 104, 126, 226, 57, 66, 141, 36, 197, 221, 113, 24, 247, 51, 159, 225, 141, 120, 210, 148, 74, 5, 16, 38, 195, 14, 78, 245, 86, 42, 112, 33, 120, 207, 248, 216, 87, 200, 14, 156, 139, 144, 249, 120, 243, 218, 16, 6, 33, 76, 152, 10, 166, 187, 32, 148, 2, 166, 146, 39, 98, 87, 47, 155, 112, 192, 137, 36, 86, 247, 204, 87, 198, 135, 226, 165, 118, 8, 59, 37, 78, 51, 135, 119, 46, 1, 185, 157, 165, 105, 18, 245, 119, 48, 229, 1, 184, 89, 143, 35, 199, 201, 240, 95, 124, 93, 212, 81, 75, 215, 16, 198, 236, 114, 167, 109, 181, 226, 38, 90, 21, 128, 130, 162, 146, 60, 238, 195, 137, 121, 196, 33, 255, 214, 43, 134, 216, 193, 106, 215, 116, 69, 177, 139, 146, 157, 157, 86, 187, 131, 184, 118, 230, 184, 124, 16, 149, 96, 72, 74, 158, 115, 135, 139, 124, 181, 173, 66, 244, 105, 249, 199, 179, 50, 59, 1, 136, 147, 50, 198, 110, 132, 161, 149, 219, 123, 6, 70, 36, 90, 220, 38, 128, 250, 53, 101, 167, 111, 249, 131, 211, 160, 178, 103, 3, 134, 2, 191, 18, 161, 247, 212, 34, 57, 240, 179, 124, 11, 213, 212, 224, 248, 5, 56, 228, 19, 209, 198, 246, 72, 77, 105, 197, 42, 135, 244, 199, 53, 7, 12, 124, 247, 16, 219, 24, 142, 133, 30, 144, 163, 111, 12, 102, 37, 252, 121, 253, 9, 37, 255, 169, 206, 203, 180, 25, 190, 215, 155, 1, 105, 129, 52, 93, 199, 250, 51, 164, 29, 29, 55, 93, 23, 126, 82, 143, 44, 131, 128, 247, 182, 62, 150, 44, 180, 21, 246, 23, 125, 215, 232, 51, 160, 130, 159, 111, 177, 129, 229, 193, 216, 197, 207, 14, 99, 93, 202, 171, 159, 97, 33, 29, 236, 113, 165, 191, 37, 94, 249, 83, 169].as_slice());
        let expected_secret_key = ByteArray::from([250, 113, 152, 133, 222, 85, 115, 91, 240, 50, 94, 203, 21, 172, 236, 7, 53, 30, 216, 72, 132, 114, 94, 81, 52, 79, 203, 202, 37, 47, 1, 13].as_slice());

        assert_eq!(ciphertext, expected_ciphertext);
        assert_eq!(secret_key, expected_secret_key);
    }

    #[test]
    fn test_decrypt() {
        let seed = ByteArray::from([0u8; 64].as_slice());
        let kyber = Kyber512::init();
        let (public_key, private_key) = kyber.keygen(seed);
        let seed = ByteArray::from([0u8; 32].as_slice());
        let shared_secret_key_size = 32;
        let (ciphertext, secret_key) = kyber.encrypt(public_key, seed, shared_secret_key_size);
        let secret_key_prime = kyber.decrypt(ciphertext, private_key, shared_secret_key_size);

        assert_eq!(secret_key, secret_key_prime)
    }
}
